### Objectif du cours

But du cours: apprendre à développer un logiciel

Souvent: problèmes au-delà de la technique (ex: argent...)

#### Définition

Génie logiciel: appliquer une approche systématique au développement d'un logiciel

#### Cycle

- Déterminer les besoins du client
- Design: comment va-t-on répondre à ce besoin
- Implémentation
- Tester le code
- Maintenance

#### Capturer le besoin

- Le premier problème est de discossier le problème de la solution... Ne pas réfléchir à la solution pendant qu'on explique le problème !
- Il ne faut pas laisser le client dicter la solution
- Parler plus avec le client pour mieux capturer le besoin... Il faut réussir à trouver un langage commun (différents métiers -> différents langages...)

- unitaire
- complet
- consistent: pas un requirement en contradiction avec un autre...
- tracabilité: 
- non ambigu
- priorité: décider ce qui est plus prioritaire
- vérifiable: il faut pouvoir les tester

must have, should have, need to have ?

#### Types de besoins

- fonctionnels: c'est ce qui permet de définir ce dont le client a besoin
- pas fonctionnels: ce serait tout ce qui finit par 'ity' en anglais (ex: security, performances, ...)

#### Coût du logiciel

- développement
- marketing
- ...

### User stories

But: pouvoir expliquer son projet et en quoi il est inovant en 1 minute
User storie: As a <type of user>, I want to <some goal> so that <reason to achieve the goal>

Use case: fait la même chose, mais en diagramme uml....

Storyboard: Définir comment sera l'interface (en gros...)
Ne pas trop faire une interface réaliste: Il faut qu'elle soit irréaliste pour éviter de commencer à parler du look de l'interface....

Non-functionnal requirement (NFR) defines how the system operates NOT what it does.

## Organisation et planning

### Waterfall
requirements -> design -> implementation -> verification

Impossible car le monde change beaucoup trop vite. Pas assez flexible...

### V-Cycle
diminue le risque de dévier complètement

problème en temps de réactivité

### Itératif et incrémentaux
on fait des boucles requirements -> design etc...

### Agile
idée: focus sur les individus et les interactions avec les individus... Fait d'avantage confiance aux gens et se concentrer sur logiciel qui marche plus que sur la doc.
Être d'accord de répondre au changement !!!! C'est la règle la plus importante !!!!!!!
- Accueillir le changement favorablement
- livrer fréquement des nouveautés aux clients -> permet d'avoir souvent des feedbacks du client -> permet d'avoir moins d'attachement au code -> éviter l'effet Golum !!!!
- Il vaut mieux 1 personne super motivée plutôt que 10 personnes pas motivées -> garder la motivation !
- fournir aux équipes l'environnement et le support pour qu'ils puissent s'éclater dans leur taf
- Avoir quelqu'un en face de soi n'a rien à voir avec une collaboration par document/teams etc...
- Tous les jours, les tests sont tous verts... Il faut avoir quelque chose qui marche tout le temps !!!! -> ne pas faire péter les builds -> Très important !!!!!
- But: rapport entre vie privée et vie professionnelle -> réussir à garder une limite !!!!!!
- Toujours s'aménager du temps pour apprendre !!!!!! Permet de rester continuellement à jour ! (2h par semaine par exemple)
- Il faut être fainéant !!!!!!!!!!! ne pas faire de travail manuel !!!!! Tout automatiser !!!!!
- Rétrospective: Se poser la question de ce qui a marché et de ce qui n'a pas marché.

### Architecture

Part à partir des arguments qualités !!

architecture: Définir la structure du logiciel à un haut niveau

Il y a un manifeste de la méthode agile.


#### Idée

trouver u
tracking 3D
partition recogniser

